--- ../wmx-6pl1-orig/Buttons.C	2001-04-24 04:56:39.000000000 -0400
+++ Buttons.C	2005-03-06 14:08:26.998250320 -0500
@@ -39,11 +39,11 @@
     }
 #endif
  
-    if (e->button == Button4 && CONFIG_CHANNEL_SURF) {
+    if (e->button == PREV_CHANNEL_BUTTON && CONFIG_CHANNEL_SURF) {
         // wheel "up" - increase channel
         flipChannel(False, False, True, c);
         return ;
-    } else if (e->button == Button5 && CONFIG_CHANNEL_SURF) {
+    } else if (e->button == NEXT_CHANNEL_BUTTON && CONFIG_CHANNEL_SURF) {
         // wheel "down" - decrease channel
         flipChannel(False, True, True, c);
         return ;
@@ -163,7 +163,8 @@
 {
     enum {Vertical, Maximum, Horizontal};
     KeySym key = XKeycodeToKeysym(display(), ev->keycode, 0);
-    
+    char *command;
+
     if (CONFIG_USE_KEYBOARD) {
 
 	Client *c = windowToClient(ev->window);
@@ -239,7 +240,12 @@
 //                (long)ev->state, (long)m_altModMask);
            }
 
-           if (key >= XK_F1 && key <= XK_F12 &&
+	   command = key_binding_with_mod->command_for_keysym(key);
+	   if (command) {
+		 key_binding_with_mod->spawn(command, c ? c->window() : 0);
+	   }
+
+           else if (key >= XK_F1 && key <= XK_F12 &&
 		CONFIG_CHANNEL_SURF && CONFIG_USE_CHANNEL_KEYS) {
 
 		int channel = key - XK_F1 + 1;
@@ -342,6 +348,13 @@
 		    return;
 		}
 	    }
+	} else {
+
+	    command = key_binding_without_mod->command_for_keysym(key);
+	    if (command) {
+	      key_binding_without_mod->spawn(command, c ? c->window() : 0);
+	    }
+
 	}
 
 	XSync(display(), False);
--- ../wmx-6pl1-orig/Client.C	2000-05-12 03:40:20.000000000 -0400
+++ Client.C	2005-03-06 14:08:27.005249256 -0500
@@ -16,6 +16,18 @@
 
 const char *const Client::m_defaultLabel = "incognito";
 
+int compare_client_names(Client *c1, Client *c2)
+{
+    int n;
+
+    n = strcmp(c1->m_className, c2->m_className);
+    if (n == 0) {
+	n = strcmp(c1->m_label, c2->m_label);
+    }
+    return n;
+}
+
+
 
 
 Client::Client(WindowManager *const wm, Window w, Boolean shaped) :
@@ -56,6 +68,7 @@
     
     m_label = NewString(m_defaultLabel);
     m_border = new Border(this, w);
+    m_className = NewString("???");
 
     m_channel = wm->channel();
     m_unmappedForChannel = False;
@@ -338,8 +351,20 @@
 	}
     }
 
+    m_windowManager->key_binding_with_mod->
+      grab_each_key(display(), m_window,
+		    m_windowManager->altModMask());
+
+    m_windowManager->key_binding_without_mod->
+      grab_each_key(display(), m_window, 0);
+
     m_iconName = getProperty(XA_WM_ICON_NAME);
     m_name = getProperty(XA_WM_NAME);
+    m_className = getProperty(XA_WM_CLASS);
+    if (!m_className) {
+	printf("Setting default m_className\n");
+	m_className = NewString("??");
+    }
     setLabel();
 
     getColormaps();
@@ -806,6 +831,13 @@
     m_y += h;
 }
 
+void Client::setLabel(char *label)
+{
+      if (m_label) {
+	    free((void *)m_label);
+      }
+      m_label = NewString(label);
+}
 
 Boolean Client::setLabel(void)
 {
@@ -829,6 +861,24 @@
     } else return True;//False;// dammit!
 }
 
+char * Client::make_class_and_label_name(void)
+{
+      /* Return "[res_name] label" */
+      char *p, *start;
+      int n;
+
+      n = 4 + strlen(m_className) + strlen(m_label);
+      start = p = (char *)malloc(n);
+      *p++ = '[';
+      strcpy(p, m_className);
+      strcat(start, "] ");
+      strcat(start, m_label);
+      return start;
+}
+
+
+
+
 
 void Client::getColormaps(void)
 {
@@ -1290,6 +1340,33 @@
     }
 }
 
+void Client::move(int x, int y, Boolean relative)
+{
+    int width = DisplayWidth(display(), 0);
+    int height = DisplayHeight(display(), 0);
+
+    if (relative) {
+	m_x += x;
+	m_y += y;
+    } else {
+	m_x = x;
+	m_y = y;
+    }
+    if (m_x < 0) {
+	m_x = 0;
+    } else if (m_x + m_w > width) {
+	m_x = width - m_w;
+    }
+    if (m_y < 0) {
+	m_y = 0;
+    } else if (m_y + m_h > height) {
+	m_y = height - m_h;
+    }
+    // printf("moving to %d %d\n", m_x, m_y);
+    m_border->moveTo(m_x, m_y);
+    sendConfigureNotify();
+}
+
 #if CONFIG_GNOME_COMPLIANCE != False
 void Client::gnomeSetChannel() {
 
--- ../wmx-6pl1-orig/Client.h	2001-04-24 04:58:31.000000000 -0400
+++ Client.h	2005-03-06 14:08:27.011248344 -0500
@@ -30,6 +30,7 @@
 				// otherwise lower.
 
     void move(XButtonEvent *);		// event for grab timestamp & coords
+    void move(int, int, Boolean);
     void resize(XButtonEvent *, Boolean, Boolean);
     void moveOrResize(XButtonEvent *);
     void ensureVisible();	// make sure x, y are on-screen
@@ -114,9 +115,15 @@
 
 #if CONFIG_GNOME_COMPLIANCE != False
     void gnomeSetChannel();
-    Window window()        { return m_window; }
 #endif
 
+
+    Window window()        { return m_window; }
+    void setLabel(char *);
+    char * Client::make_class_and_label_name(void);
+    friend int compare_client_names(Client *c1, Client *c2);
+
+
 protected:      // cravenly submitting to gcc's warnings
     ~Client();
 
@@ -173,6 +180,7 @@
 
     char *m_name;
     char *m_iconName;
+    char *m_className;
     const char *m_label;	// alias: one of (instance,class,name,iconName)
     static const char *const m_defaultLabel;
 
--- ../wmx-6pl1-orig/Config.C	2000-03-02 08:56:35.000000000 -0500
+++ Config.C	2005-03-06 14:08:27.017247432 -0500
@@ -21,6 +21,8 @@
     int  feeddelay;
     char disable;	// 0 = New Window option, 1 = no New
     char rightBt;	// 0 = disable, 1 = circulate, 2 = lower, 4 = height
+    char className;	// 0 = no,  1 = yes (add class name to menu)
+    char sortClients;	// 0 = no, 1 = yes
 };  
 
 DynamicConfig::DynamicConfig() : m_impl(new DynamicConfigImpl)
@@ -57,7 +59,8 @@
     m_impl->feeddelay = 300;
     m_impl->disable = 0;        // 0 = allow New window, 1 = don't
     m_impl->rightBt = 1;	// 0 = disable, 1 = circulate, 2 = lower
-
+    m_impl->className = 0;	// 0 = no class name in menu,  1 = yes
+    m_impl->sortClients = 0;	// 0 = no, 1 = yes
     scan(1);
 }
 
@@ -78,6 +81,8 @@
 char DynamicConfig::rightCirculate() { return m_impl->rightBt & 1; }
 char DynamicConfig::rightLower() { return m_impl->rightBt & 2; }
 char DynamicConfig::rightToggleHeight() { return m_impl->rightBt & 4; }
+char DynamicConfig::classInMenu() { return m_impl->className & 1; }
+char DynamicConfig::sortClients() { return m_impl->sortClients & 1; }
 
 void DynamicConfig::scan(char startup)
 {
@@ -95,9 +100,10 @@
 }
 
 
-void DynamicConfig::update(char *string)
+int DynamicConfig::update(char *string)
 {
     char *s;
+    int errors = 0;
 
 #define OPTION(x) ( (!strncasecmp(s, x, strlen(x))) && (s += strlen(x)) )
 
@@ -138,15 +144,25 @@
 	    else if (OPTION("circulate")) m_impl->rightBt = 1;
 	    else if (OPTION("lower")) m_impl->rightBt = 2;
 	    else if (OPTION("toggleheight")) m_impl->rightBt = 4;
-	
+
+	if (OPTION("class:"))
+	    if (OPTION("on")) m_impl->className = 1;
+	    else if (OPTION("off")) m_impl->className = 0;
+
+	if (OPTION("sort:"))
+	    if (OPTION("on")) m_impl->sortClients = 1;
+	    else if (OPTION("off")) m_impl->sortClients = 0;
+
 	if (*s != '\0') {
 	    fprintf(stderr, "\nwmx: Dynamic configuration error: "
 		    "`%s' @ position %d", s, string - s);
+	    errors++;
 	}
 
     } while (s = strtok(NULL, "/"));
 
     fprintf(stderr, "\n");
+    return errors;
 
 #undef OPTION
 }
--- ../wmx-6pl1-orig/Config.h	2001-04-23 11:48:31.000000000 -0400
+++ Config.h	2005-03-06 14:08:27.023246520 -0500
@@ -51,12 +51,16 @@
     char rightCirculate();
     char rightLower();
     char rightToggleHeight();
+    char classInMenu();
+    char sortClients();
 
     static DynamicConfig dynamicConfig;
+    // made public for now...  and made int
+    int update(char *);
 
 private:
     DynamicConfigImpl *m_impl;
-    void update(char *);
+    // void update(char *);
 };
 
 static DynamicConfig &dConfig = DynamicConfig::dynamicConfig;
@@ -75,8 +79,8 @@
 
 // What to run to get a new window (from the "New" menu option)
 #define CONFIG_NEW_WINDOW_LABEL "New"
-//#define CONFIG_NEW_WINDOW_COMMAND "xterm"
-#define CONFIG_NEW_WINDOW_COMMAND "/home/chris/.wmx/terminal"
+#define CONFIG_NEW_WINDOW_COMMAND "xterm"
+// #define CONFIG_NEW_WINDOW_COMMAND "/home/chris/.wmx/terminal"
 #define CONFIG_NEW_WINDOW_COMMAND_OPTIONS 0
 // or, for example,
 //#define CONFIG_NEW_WINDOW_COMMAND_OPTIONS "-ls","-sb","-sl","1024",0
@@ -167,6 +171,13 @@
 
 #define MENU_ENTRY_MAXLENGTH		80
 
+// The default is wheel up (button 4) increases the channel
+#define PREV_CHANNEL_BUTTON Button4
+#define NEXT_CHANNEL_BUTTON Button5
+// To have wheel down increase the channel switch,  then
+// comment the previous two and uncomment these:
+// #define NEXT_CHANNEL_BUTTON Button4
+// #define PREV_CHANNEL_BUTTON Button5
 
 // ========================
 // Section II. Key bindings
@@ -234,6 +245,16 @@
 #define CONFIG_SUNPOWER_OPTIONS	"-x","-h",0
 #define CONFIG_SUNPOWER_SHIFTOPTIONS	"-x","-n",0
 
+// If menus should have the client class displayed
+// #define CLASS_IN_MENU False
+// #define CLASS_IN_MENU True
+// Dynamic option:  class: on|off
+#define CLASS_IN_MENU	(dConfig.classInMenu())
+
+// Should clients be sorted when displayed on menu or for the
+// clients command in remote control?
+// Can be set to False, True or (dConfig.sortClients())
+#define SORT_CLIENTS (dConfig.sortClients())
 
 // ==============================
 // Section III. Colours and fonts
--- ../wmx-6pl1-orig/Events.C	2001-08-31 04:02:49.000000000 -0400
+++ Events.C	2005-03-06 14:08:27.030245456 -0500
@@ -1,7 +1,7 @@
 
 #include "Manager.h"
 #include "Client.h"
-
+#include "Remote.h"
 
 int WindowManager::loop()
 {
@@ -192,36 +192,62 @@
 	}
 
 	XFlush(m_display);
-	FD_SET(fd, &rfds);
+
+	memcpy((void *)&rfds, (void *)&active_fds, sizeof(rfds));
 	t.tv_sec = 0; t.tv_usec = 20000;
 
 #if CONFIG_USE_SESSION_MANAGER != False
 	if (m_smFD >= 0) FD_SET(m_smFD, &rfds);
 #endif
 
-	if ((r = select(fd + 1, &rfds, NULL, NULL,
+	if ((r = select(max_fd, &rfds, NULL, NULL,
 			(m_channelChangeTime > 0 || m_focusChanging) ? &t :
 			(struct timeval *)NULL)) > 0) {
 
+	    int f;
+	    int did_something = 0;
+	    for (f=0; f < max_fd; f++) {
+		  if (FD_ISSET(f, &rfds)) {
+			// fprintf(stderr, "%d is set\n", f);
 #if CONFIG_USE_SESSION_MANAGER != False
-	    if (m_smFD >= 0 && FD_ISSET(m_smFD, &rfds)) {
-		Bool rep;
-                if (IceProcessMessages(m_smIceConnection, NULL, &rep)
-                    == IceProcessMessagesIOError) {
-                    SmcCloseConnection(m_smConnection, 0, NULL);
-		    m_smIceConnection = NULL;
-		    m_smConnection = NULL;
-                }
-		goto waiting;
-	    }
+			// if (m_smFD >= 0 && FD_ISSET(m_smFD, &rfds)) {
+			if (f == m_smFD) {
+			      Bool rep;
+			      if (IceProcessMessages(m_smIceConnection, NULL, &rep)
+				  == IceProcessMessagesIOError) {
+				    SmcCloseConnection(m_smConnection, 0, NULL);
+				    m_smIceConnection = NULL;
+				    m_smConnection = NULL;
+			      }
+			      // goto waiting;
+			      did_something++;
+			}
 #endif
-	    if (FD_ISSET(fd, &rfds)) {
-		XNextEvent(m_display, e);
-		return;
+
+			if (remote_control->isRemoteControlFd(f)) {
+			      did_something++;
+			      if (! remote_control->doRemoteControl(f) ) {
+				    // fprintf(stderr, "doRemoteControl(%d) ??\n", f);
+				    // If a connection has closed,  the
+				    // active_fd set has changed
+				    goto waiting;
+			      }
+			}
+
+			// if (FD_ISSET(fd, &rfds)) {
+			if (f == fd) {
+			      XNextEvent(m_display, e);
+			      return;
+			}
+
+		  }
+	    } // for all fds in the set
+	    if (did_something) {
+		  goto waiting;
 	    }
 
 //	    return;
-	}
+	} // if select found something
 
 	if (CONFIG_AUTO_RAISE && m_focusChanging) { // timeout on select
 	    checkDelaysForFocus();
@@ -410,7 +436,7 @@
     XConfigureWindow(display(), e->window, e->value_mask, &wc);
 
     // if parent==root, it's not managed yet -- & it'll be raised when it is
-    if (raise && (parent() != root())) {
+    if (raise && parent() != root()) {
 
 	if (CONFIG_AUTO_RAISE) {
 
--- ../wmx-6pl1-orig/Keybinding.C	1969-12-31 19:00:00.000000000 -0500
+++ Keybinding.C	2005-03-06 14:08:27.036244544 -0500
@@ -0,0 +1,191 @@
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <string.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+#include <sys/wait.h>
+
+#include "Keybinding.h"
+
+int Keybinding::scan_directory(char *dir_name, bool with_modifier)
+{
+
+    DIR *dir;
+    struct dirent *ent;
+    struct stat buf;
+    int n;
+    char filename[1024];
+    int pass = 0;
+    int count = 0;
+    struct key_entry *p;
+    KeySym sym;
+
+    table_count = 0;
+    n = stat(dir_name, &buf);
+    if (n != 0 || !S_ISDIR(buf.st_mode)) {
+	printf("Directory %s does not exist\n", dir_name);
+	return -1;
+    }
+    dir = opendir(dir_name);
+    if (dir == NULL) {
+	printf("Could not open directory %s\n", dir_name);
+	return -1;
+    }
+
+    for (pass=0; pass<2; pass++) {
+	count = 0;
+	while (ent = readdir(dir)) {
+	    // printf("%s type: %d\n", ent->d_name, ent->d_type);
+	    sprintf(filename, "%s/%s", dir_name, ent->d_name);
+	    n = stat(filename, &buf);
+	    // printf("type 0%o\n", buf.st_mode);
+	    if (n != 0) {
+		printf("stat failed for %s, n = %d\n", filename, n);
+		continue;
+	    }
+	    if (!S_ISREG(buf.st_mode)) {
+		// printf("not a regular file\n");
+		continue;
+	    }
+	    if (S_ISDIR(buf.st_mode)) {
+		// printf("is a directory\n");
+		continue;
+	    }
+	    // S_ISLNK(buf.st_mode) doesn't work
+	    // but we probably don't need to exclude them anyway
+
+	    if (! (buf.st_mode & S_IXUSR) ) {
+		// printf("is NOT executable\n");
+		continue;
+	    }
+	    sym = XStringToKeysym(ent->d_name);
+	    if (sym == 0) {
+		printf("not suitable filename: %s\n", ent->d_name);
+		continue;
+	    }
+
+	    // it is valid
+	    // printf("valid filename %s  sym is 0x%x\n", filename, sym);
+
+	    count++;
+	    if (pass == 0) {
+		continue;
+	    } else {
+		if (count > table_count) {
+		    printf("internal error count=%d table_count=%d\n",
+			   count, table_count);
+		    exit(2);
+		}
+		p->sym = sym;
+		p->command = strdup(filename);
+		p++;
+	    }
+
+	} // while readdir
+	if (pass == 0) {
+	    // end of first pass
+	    // printf("There were %d entries found\n", count);
+	    table_count = count;
+	    p = table = (struct key_entry *)
+		malloc( count * sizeof(struct key_entry) );
+	    if (table == NULL) {
+		printf("Cannot allocate user key table\n");
+		exit(1);
+	    }
+	    rewinddir(dir);
+	}
+    }
+    if (with_modifier) {
+      printf("These keys are dynamically bound if the modifier key is active\n");
+    } else {
+      printf("These keys are dynamically bound if there is no modifier.\n");
+    }
+
+    int i;
+    for (i=0; i < table_count; i++) {
+	printf("0x%x  %s\n", table[i].sym, table[i].command);
+    }
+
+    closedir(dir);
+
+}
+
+Keybinding::Keybinding(WindowManager *const w_mgr, char *dir, 
+		       bool with_modifier)
+{
+    char key_dir_name[1024];
+    int n;
+    char *home = getenv("HOME");
+    char *keys_name = ".keys";
+
+    if (with_modifier) {
+      keys_name = ".mkeys";
+    }
+    wm = w_mgr;
+    if (dir) {
+	sprintf(key_dir_name, "%s/%s", dir, keys_name);
+    } else {
+	sprintf(key_dir_name, "%s/%s/%s", home, CONFIG_COMMAND_MENU, keys_name);
+    }
+    n = scan_directory(key_dir_name, with_modifier);
+
+}
+
+Keybinding::~Keybinding()
+{}
+
+
+void Keybinding::setup(void) 
+{}
+
+char *Keybinding::command_for_keysym(KeySym sym)
+{
+    int i;
+
+    for (i=0; i < table_count; i++) {
+	if (sym == table[i].sym) {
+	    return table[i].command;
+	}
+    }
+    return NULL;
+}
+
+
+void Keybinding::spawn(char *command, int windowid)
+{
+    char client_id[1024];
+    sprintf(client_id, "0x%x", windowid);
+
+    // printf("arg1 is %s\n", client_id);
+    wm->spawn(command, command, client_id);
+
+}
+
+void Keybinding::grab_each_key(Display *display, Window window, int mask) {
+    int i;
+    int keycode;
+
+    for (i=0; i < table_count; i++) {
+	keycode = XKeysymToKeycode(display, table[i].sym);
+	XGrabKey(display, keycode,
+		 mask,
+		 window, False,
+		 GrabModeAsync, GrabModeAsync);
+	XGrabKey(display, keycode,
+		 mask|LockMask|Mod2Mask,
+		 window, False,
+		 GrabModeAsync, GrabModeAsync);
+	XGrabKey(display, keycode,
+		 mask|LockMask,
+		 window, False,
+		 GrabModeAsync, GrabModeAsync);
+	XGrabKey(display, keycode,
+		 mask|Mod2Mask,
+		 window, False,
+		 GrabModeAsync, GrabModeAsync);
+    }
+}
--- ../wmx-6pl1-orig/Keybinding.h	1969-12-31 19:00:00.000000000 -0500
+++ Keybinding.h	2005-03-06 14:08:27.041243784 -0500
@@ -0,0 +1,31 @@
+
+#ifndef __KEYBINDING_H_
+#define __KEYBINDING_H_
+
+#include "Manager.h"
+
+struct key_entry {
+      KeySym	sym;
+      char	*command;
+} ;
+
+class WindowManager;
+class Keybinding {
+ public:
+    Keybinding::Keybinding(WindowManager *const, char *, bool);
+    ~Keybinding();
+    void Keybinding::setup(void);
+    char * Keybinding::command_for_keysym(KeySym sym);
+    void Keybinding::spawn(char *command, int);
+    void Keybinding::grab_each_key(Display *display, Window window, int mask);
+
+
+ private:
+    WindowManager *wm;
+    int Keybinding::scan_directory(char *dir_name, bool with_modifier);
+    int table_count;
+    struct key_entry *table;
+
+};
+
+#endif
--- ../wmx-6pl1-orig/Makefile.in	1999-08-31 19:53:08.000000000 -0400
+++ Makefile.in	2005-03-06 14:08:27.047242872 -0500
@@ -17,7 +17,7 @@
 #CFLAGS = -g -O2 -I/usr/include -I/usr/openwin/include
 CXXFLAGS=@CXXFLAGS@
 
-OBJECTS	= Border.o Buttons.o Channel.o Client.o Config.o Events.o Main.o Manager.o Menu.o Rotated.o Session.o
+OBJECTS	= Border.o Buttons.o Channel.o Client.o Config.o Events.o Main.o Manager.o Menu.o Rotated.o Session.o Keybinding.o Remote.o
 
 .C.o:
 	$(CCC) -c $(CXXFLAGS) $<
@@ -48,21 +48,26 @@
 
 # DO NOT DELETE -- make depend depends on it
 Border.o: Border.C Border.h General.h Config.h Rotated.h Client.h \
- Manager.h listmacro.h background.xpm
-Buttons.o: Buttons.C Manager.h General.h Config.h listmacro.h Client.h \
- Border.h Rotated.h Menu.h
-Channel.o: Channel.C Manager.h General.h Config.h listmacro.h Client.h \
- Border.h Rotated.h
-Client.o: Client.C Manager.h General.h Config.h listmacro.h Client.h \
- Border.h Rotated.h
+  Manager.h listmacro.h Keybinding.h Remote.h background.xpm
+Buttons.o: Buttons.C Manager.h General.h Config.h listmacro.h \
+  Keybinding.h Remote.h Client.h Border.h Rotated.h Menu.h
+Channel.o: Channel.C Manager.h General.h Config.h listmacro.h \
+  Keybinding.h Remote.h Client.h Border.h Rotated.h
+Client.o: Client.C Manager.h General.h Config.h listmacro.h Keybinding.h \
+  Remote.h Client.h Border.h Rotated.h
 Config.o: Config.C Config.h
-Events.o: Events.C Manager.h General.h Config.h listmacro.h Client.h \
- Border.h Rotated.h
-Main.o: Main.C Manager.h General.h Config.h listmacro.h Client.h \
- Border.h Rotated.h
-Manager.o: Manager.C Manager.h General.h Config.h listmacro.h Menu.h \
- Client.h Border.h Rotated.h Cursors.h
+Events.o: Events.C Manager.h General.h Config.h listmacro.h Keybinding.h \
+  Remote.h Client.h Border.h Rotated.h
+Keybinding.o: Keybinding.C Keybinding.h Manager.h General.h Config.h \
+  listmacro.h Remote.h
+Main.o: Main.C Manager.h General.h Config.h listmacro.h Keybinding.h \
+  Remote.h Client.h Border.h Rotated.h
+Manager.o: Manager.C Manager.h General.h Config.h listmacro.h \
+  Keybinding.h Remote.h Menu.h Client.h Border.h Rotated.h Cursors.h
 Menu.o: Menu.C Menu.h General.h Config.h Manager.h listmacro.h \
- Client.h Border.h Rotated.h
+  Keybinding.h Remote.h Client.h Border.h Rotated.h
+Remote.o: Remote.C Remote.h Manager.h General.h Config.h listmacro.h \
+  Keybinding.h Client.h Border.h Rotated.h
 Rotated.o: Rotated.C Config.h Rotated.h
-Session.o: Session.C Manager.h General.h Config.h listmacro.h
+Session.o: Session.C Manager.h General.h Config.h listmacro.h \
+  Keybinding.h Remote.h
--- ../wmx-6pl1-orig/Manager.C	2001-04-23 05:10:42.000000000 -0400
+++ Manager.C	2005-03-06 14:08:27.055241656 -0500
@@ -46,6 +46,7 @@
 implementPList(ListList, ClientList);
 #endif
 
+#define DEFAULT_PORT 6999
 WindowManager::WindowManager(int argc, char **argv) :
     m_focusChanging(False),
     m_altPressed(False),
@@ -54,7 +55,10 @@
 {
     char *home = getenv("HOME");
     char *wmxdir = getenv("WMXDIR");
-    
+
+    max_fd = 0;
+    memset((void *)&active_fds, 0, sizeof(fd_set));
+
     fprintf(stderr, "\nwmx: Copyright (c) 1996-2001 Chris Cannam."
 	    "  Sixth release, April 2001\n"
 	    "     Parts derived from 9wm Copyright (c) 1994-96 David Hogan\n"
@@ -70,7 +74,11 @@
 #if CONFIG_USE_SESSION_MANAGER != False
     char *oldSessionId = 0;
 #endif
-    
+
+
+    // remote_control = NULL;
+    remote_control = new Remote(this);
+
     if (argc > 1) {
 
 #if CONFIG_USE_SESSION_MANAGER != False
@@ -79,11 +87,46 @@
 	    oldSessionId = argv[2];
 	} else {
 #endif
+	    {
+		int	c ;
+		int	port;
+		int	verbose = 0;
+
+		port = 0;
+		while ( (c = getopt(argc, argv, "rp:v")) != EOF ) {
+		    switch(c) {
+		    case 'r':
+			port = DEFAULT_PORT;
+			break ;
+		    case 'p':
+			port = atoi(optarg) ;
+			break ;
+		    case 'v':
+			verbose++ ;
+			break ;
+		    case '?':
+		    default:
+			fprintf(stderr, "bad option\n") ;
+			exit(1) ;
+		    }
+		}
+
+		if (port > 0) {
+		    //remote_control_socket = setup_socket("localhost", port);
+		    // remote_control = Remote::Remote(this, port);
+		    remote_control->setup_port(port, verbose);
+		}
+
+
+	    }
+
 
-	for (i = strlen(argv[0])-1; i > 0 && argv[0][i] != '/'; --i);
-	fprintf(stderr, "\nwmx: Usage: %s [-clientId id]\n",
-		argv[0] + (i > 0) + i);
-	exit(2);
+	    if (optind < argc) {
+		for (i = strlen(argv[0])-1; i > 0 && argv[0][i] != '/'; --i);
+		fprintf(stderr, "\nwmx: Usage: %s [-clientId id]\n",
+			argv[0] + (i > 0) + i);
+		exit(2);
+	    }
 
 #if CONFIG_USE_SESSION_MANAGER != False
 	}
@@ -196,6 +239,11 @@
         fprintf(stderr, "\n     Not GNOME compliant.");
     }
 
+    if (remote_control->RemoteControlIsOn()) {
+	  fprintf(stderr, "\n     Remote control on port %d.",
+		  remote_control->RemoteControlIsOn());
+    }
+
     fprintf(stderr, "\n     Command menu taken from ");
     if (wmxdir == NULL) {
 	fprintf(stderr, "%s/%s.\n", home, CONFIG_COMMAND_MENU);
@@ -212,6 +260,8 @@
     m_display = XOpenDisplay(NULL);
     if (!m_display) fatal("can't open display");
 
+    add_fd_to_watch(ConnectionNumber(m_display));
+
     m_shell = (char *)getenv("SHELL");
     if (!m_shell) m_shell = NewString("/bin/sh");
 
@@ -231,7 +281,10 @@
     XSetErrorHandler(errorHandler);
     ignoreBadWindowErrors = False;
 
-    // 9wm does more, I think for nohup
+    key_binding_with_mod = new Keybinding(this, wmxdir, true);
+    key_binding_without_mod = new Keybinding(this, wmxdir, false);
+
+    // 9wm does mRore, I think for nohup
     signal(SIGTERM, sigHandler);
     signal(SIGINT,  sigHandler);
     signal(SIGHUP,  sigHandler);
@@ -922,7 +975,7 @@
 }
 #endif
 
-void WindowManager::spawn(char *name, char *file)
+void WindowManager::spawn(char *name, char *file, char *arg1 /* = NULL*/)
 {
     // strange code thieved from 9wm to avoid leaving zombies
 
@@ -932,6 +985,9 @@
 	if (fork() == 0) {
 
 	    close(ConnectionNumber(m_display));
+	    if (remote_control->RemoteControlIsOn()) {
+		  remote_control->close_all_sockets();
+	    }
 
 	    // if you don't have putenv, miss out this next
 	    // conditional and its contents
@@ -949,14 +1005,14 @@
 	    }
 
 	    if (CONFIG_EXEC_USING_SHELL) {
-		if (file) execl(m_shell, m_shell, "-c", file, 0);
-		else execl(m_shell, m_shell, "-c", name, 0);
+		if (file) execl(m_shell, m_shell, "-c", file, arg1, 0);
+		else execl(m_shell, m_shell, "-c", name, arg1, 0);
 		fprintf(stderr, "wmx: exec %s", m_shell);
 		perror(" failed");
 	    }
 
 	    if (file) {
-		execl(file, name, 0);
+		execl(file, name, arg1, 0);
 	    }
 	    else {
 		if (strcmp(CONFIG_NEW_WINDOW_COMMAND, name)) {
@@ -978,6 +1034,79 @@
     wait((int *) 0);
 }
 
+int compare_client_names_a(const void *p, const void *q)
+{
+    // This is necessary because we get called the parameter void *
+    // needs to be derefenced twice to get a Client type.
+    Client **x1 = (Client **) p;
+    Client **x2 = (Client **) q;
+
+    Client *c1 = *x1;
+    Client *c2 = *x2;
+
+    return compare_client_names(c1, c2);
+}
+
+void WindowManager::print_clients(int fd) {
+      int i;
+      char buff[1024];
+      Client *c;
+      XTextProperty text_prop;
+      char *res_name = "?";
+
+      //      if (SORT_CLIENTS) {
+      //	  this->sort_clients();
+      //}
+
+      // printf("Number of clients: %d\n", m_clients.count());
+      // sprintf(buff, "Number of clients: %d\n", clients().count());
+      // write(fd, buff, strlen(buff));
+      if (m_clients.count() == 0) {
+	  sprintf(buff, "No clients!\n");
+	  write(fd, buff, strlen(buff));
+      }
+      for (i = 0; i < m_clients.count(); ++i) {
+	  // printf("%s\n", m_clients.item(i)->label());
+	  c = clients().item(i);
+	  if (XGetTextProperty(c->display(), c->window(), 
+			       &text_prop, XA_WM_CLASS)) {
+	      res_name = (char *)text_prop.value;
+	  }
+	  sprintf(buff,
+		  "0x%x %d %c%c%c (%s) \"%s\"\n", 
+		  c->window(),
+		  c->channel(),
+		  c->isHidden() ? 'H' :  '-',
+		  c->isWithdrawn() ? 'W' :  '-',
+		  c->isSticky() ? 'S' : '-',
+		  res_name,
+		  c->label() );
+      write(fd, buff, strlen(buff));
+      }
+}
+
+void WindowManager::add_fd_to_watch(int fd)
+{
+    // fprintf(stderr, "adding fd %d to read_set\n", fd);
+    if (fd >= max_fd) {
+	max_fd = fd+1;
+    }
+    FD_SET(fd, &active_fds);
+}
+
+void WindowManager::remove_fd_from_watch(int fd)
+{
+    // fprintf(stderr, "removing fd %d from read_set\n", fd);
+    FD_CLR(fd, &active_fds);
+}
+
+void WindowManager::sort_clients(void)
+{
+    m_clients.sort(compare_client_names_a);
+    m_hiddenClients.sort(compare_client_names_a);
+}
+
+
 
 #if CONFIG_GNOME_COMPLIANCE != False
 
@@ -1106,6 +1235,7 @@
     gnomeUpdateCurrentChannel();
 }   
 
+
 void WindowManager::gnomeUpdateCurrentChannel()
 {
     CARD32 val;
--- ../wmx-6pl1-orig/Manager.h	2001-04-24 04:58:31.000000000 -0400
+++ Manager.h	2005-03-06 14:08:27.061240744 -0500
@@ -4,8 +4,12 @@
 
 #include "General.h"
 #include "listmacro.h"
+#include "Keybinding.h"
+#include "Remote.h"
 
 class Client;
+class Remote;
+
 declarePList(ClientList, Client);
 
 #if CONFIG_GROUPS != False
@@ -70,7 +74,7 @@
     void releaseGrab(XButtonEvent *);
     void releaseGrabKeyMode(XButtonEvent *);
     void releaseGrabKeyMode(XKeyEvent *);
-    void spawn(char *, char *);
+    void spawn(char *, char *, char * = NULL);
 
     int channel() { return m_currentChannel; }
     int channels() { return m_channels; }
@@ -102,6 +106,15 @@
     // Stupid little helper function
     static int numdigits(int);
 
+    void WindowManager::sort_clients(void);
+
+    class Keybinding *key_binding_with_mod;
+    class Keybinding *key_binding_without_mod;
+
+    void print_clients(int);
+    void add_fd_to_watch(int);
+    void remove_fd_from_watch(int fd);
+
 private:
     int loop();
     void release();
@@ -215,6 +228,30 @@
 #endif
 
     int m_altModMask;
+    /// int remote_control_port;
+
+    class Remote * remote_control;
+
+    int WindowManager::wmxsocket(int argc, char **argv);
+    /// int WindowManager::RemoteControlIsOn(void) {
+    // ///?? return remote_control_port;
+    ///  return remote_control->RemoteControlIsOn();
+    /// }
+
+    Boolean WindowManager::isRemoteControlFd(int fd);
+    Boolean WindowManager::doRemoteControl(int fd);
+
+    void WindowManager::parse_command(char *buff, int fd);
+
+    fd_set active_fds;
+
+    /// fd_set remote_control_connections;
+    /// int remote_control_socket;
+
+    int max_fd;
+    // int WindowManager::check_remote_controls(fd_set *read_fds);
+
+
 };
 
 #endif
--- ../wmx-6pl1-orig/Menu.C	2001-10-05 09:01:21.000000000 -0400
+++ Menu.C	2005-03-06 14:08:27.067239832 -0500
@@ -469,6 +469,9 @@
 ClientMenu::ClientMenu(WindowManager *manager, XEvent *e)
     : Menu(manager, e), m_allowExit(False)
 {
+    if (SORT_CLIENTS) {
+	manager->sort_clients();
+    }
     int selecting = getSelection();
 
     if (selecting == m_nItems-1 && m_allowExit) { // getItems sets m_allowExit
@@ -507,7 +510,11 @@
 
 ClientMenu::~ClientMenu()
 {
-    m_clients.remove_all();
+    if (CLASS_IN_MENU) {
+	for (int i = 0; i < m_nItems; i++) {
+	    free(m_items[i]);
+	}
+    }
     free(m_items);
 }
 
@@ -515,7 +522,6 @@
 {
     int i;
     XButtonEvent *xbev = (XButtonEvent *)m_event; // KeyEvent is similar enough
-
     for (i = 0; i < m_windowManager->hiddenClients().count(); ++i) {
 	if (
 	    m_windowManager->hiddenClients().item(i)->root() ==
@@ -564,24 +570,33 @@
 
     const char **items = (const char **)malloc(n * sizeof(char *));
 
+    int j = 0;
     for (i = 0; i < n; ++i) {
 
-	if (CONFIG_DISABLE_NEW_WINDOW_COMMAND == False) {
-
-	    if (i == 0) items[i] = CONFIG_NEW_WINDOW_LABEL;
-	    else if (m_allowExit && i > m_clients.count()) items[i] = "[Exit wmx]";
-	    else items[i] = m_clients.item(i-1)->label();
-
+	if (i == 0 && CONFIG_DISABLE_NEW_WINDOW_COMMAND == False) {
+	    if (CLASS_IN_MENU) {
+		items[i] = NewString(CONFIG_NEW_WINDOW_LABEL);
+	    } else {
+		items[i] = CONFIG_NEW_WINDOW_LABEL;
+	    }
+	} else if (i == n-1 && m_allowExit) {
+	    if (CLASS_IN_MENU) {
+		items[i] = NewString("[Exit wmx]");
+	    } else {
+		items[i] = "[Exit wmx]";
+	    }
 	} else {
-
-	    if (m_allowExit && i >= m_clients.count()) items[i] = "[Exit wmx]";
-	    else items[i] = m_clients.item(i)->label();
+	    if (CLASS_IN_MENU) {
+		items[i] = m_clients.item(j)->make_class_and_label_name();
+	    } else {
+		items[i] = m_clients.item(j)->label();
+	    }
+	    j++;
 	}
     }
  
     *niR = n;
     *nhR = nh;
-
     return (char **)items;
 }
 
@@ -621,7 +636,7 @@
 
 
 CommandMenu::CommandMenu(WindowManager *manager, XEvent *e,
-			 char* otherdir = NULL)
+			 char* otherdir /* = NULL */)
     : Menu(manager, e)
 {
     const char *home = getenv("HOME");
--- ../wmx-6pl1-orig/Menu.h	2000-05-17 06:52:56.000000000 -0400
+++ Menu.h	2005-03-06 14:08:27.077238312 -0500
@@ -15,7 +15,7 @@
     virtual int getSelection();
     static void cleanup(WindowManager *const);
     int screen() { return m_windowManager->screen(); }
- 
+
  protected:
     static Window *m_window;
     
--- ../wmx-6pl1-orig/Remote.C	1969-12-31 19:00:00.000000000 -0500
+++ Remote.C	2005-03-06 14:08:50.204722400 -0500
@@ -0,0 +1,831 @@
+
+#define DEFAULT_PORT 6999
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <string.h>	/* memcpy */
+#include <signal.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include "Remote.h"
+#include "Manager.h"
+#include "Client.h"
+
+Boolean sigpipe_happened = False;
+
+void Remote::sigpipe_handler(int signal)
+{
+    printf("SIGPIPE!\n");
+    sigpipe_happened = True;
+}
+
+Connection::Connection(int buff_size, int new_fd) 
+{
+    size = buff_size;
+    fd = new_fd;
+    buff = (char *)malloc(size);
+    room = size - 1;
+    p = buff;
+}
+
+Connection::~Connection() {
+    // printf("Connection::~Connection fd = %d\n", fd);
+    if (buff) {
+	free(buff);
+    }
+}
+
+// This is called when there is input on a remote connection.
+// The command is parsed only when a '\n' is seen so that if there
+// is a partial read or more than one command is read at once
+// things work as expected.
+//
+int Connection::store_input(Remote *r)
+{
+    int n;
+    char *next;
+
+    // printf("Connection::store_input for fd %d \n", fd);
+    // printf("size: %d  room: %d  p: 0x%x %s\n", size, room, p, p);
+
+    n = read(fd, p, room);
+    if ( n < 0 && errno == EINTR ) {
+	fprintf(stderr, "interrupted system call!\n") ;
+	return 0;	// ???
+    }
+    if ( n <= 0 ) {
+	if (r->verbose) {
+	    printf("Connection %d has closed\n", fd);
+	}
+	return -1;
+    }
+    p[n] = '\0';
+    room -= n;
+    if (r->verbose) {
+	printf("Read %d bytes from fd %d: ", n, fd);
+	printf("buff is now: %s", buff);
+    }
+
+    while ( (next = strchr(buff, '\n')) ) {
+	*next++ = '\0';
+	// printf("Found a command: %s\n", buff);
+	n = r->parse_command(buff, fd);
+	if (n < 0) {
+	    return n;
+	}
+	// for next time:
+	strcpy(buff, next);
+	room = size - strlen(buff) - 1;
+    }
+    return 0;
+}
+
+
+Remote::Remote(WindowManager *const w_mgr)
+{
+    wm = w_mgr;
+
+    verbose = 0;
+    // FD_ZERO(&remote_control_connections);
+    memset((void *)&remote_control_connections, 0, 
+	   sizeof(remote_control_connections)); // SGI's FD_ZERO is fucked
+    remote_control_port = 0;
+    remote_control_socket = -1;
+    max_connection = 0;
+    connections = NULL;
+    signal(SIGPIPE, sigpipe_handler);
+}
+
+
+Remote::~Remote()
+{
+    // empty
+}
+
+
+
+/// fd_set	connections;
+/// fd_set	fds_for_sigio;
+/// int	max_fd = 0;
+
+#define BACKLOG 5
+
+
+int Remote::setup_socket(char *host, int port)
+{
+    /* setup a connection to given port and host(name)
+     * if ok, return fd, 
+     * else return -1
+     */
+    int	fd_socket, n ;
+    struct sockaddr	socket_addr ;	/* general socket */
+    struct sockaddr_in	inet_socket_adr ;	/* inet socket */
+    struct in_addr	ip_addr ;
+    struct hostent	*h ;
+    int			opt;
+
+
+    if ( (h = gethostbyname(host)) == NULL ) {
+	perror("host not found") ;
+	return(-1) ;
+    }
+    memcpy(& ip_addr.s_addr,  h->h_addr_list[0],  sizeof(struct in_addr)) ;
+    if (verbose) {
+	fprintf(stderr, "%x\n", ip_addr.s_addr) ;
+    }
+
+    fd_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) ;
+    if (fd_socket < 0) {
+	perror("socket") ;
+	return(-1) ;
+    }
+    inet_socket_adr.sin_family = AF_INET ;
+    inet_socket_adr.sin_port = htons(port) ;
+    inet_socket_adr.sin_addr = ip_addr ;
+    memcpy( (char*) &socket_addr, (char *) &inet_socket_adr, 
+	    sizeof(socket_addr)) ;
+
+    opt = 1 ;
+    n = setsockopt(fd_socket, SOL_SOCKET, SO_REUSEADDR,
+		   &opt, sizeof(opt)) ;
+    if ( n != 0 ) {
+	perror("setsockopt SO_REUSEADDR");
+    }
+    n = setsockopt(fd_socket, SOL_SOCKET, SO_KEEPALIVE,
+		   &opt, sizeof(opt)) ;
+    if ( n != 0 ) {
+	perror("setsockopt SO_KEEPALIVE") ;
+    }
+
+    if ( bind(fd_socket, (struct sockaddr *) &socket_addr,
+	      sizeof(socket_addr)) < 0 ) {
+	perror("bind") ;
+	return(-1) ;
+    }
+    if (listen(fd_socket, BACKLOG) != 0) {
+	perror("listen") ;
+	return(-1) ;
+    }
+
+    return(fd_socket) ;
+
+} /* setup_socket */
+
+void Remote::setup_port(int port, int v)
+{
+    verbose = v;
+    // FD_ZERO(&remote_control_connections);
+    memset((void *)&remote_control_connections, 0, 
+	   sizeof(remote_control_connections)); // SGI's FD_ZERO is fucked
+    remote_control_socket = -1;
+
+    remote_control_port = port;
+    if (remote_control_port > 0) {
+
+	remote_control_socket = setup_socket("localhost", remote_control_port);
+	if (remote_control_socket < 0) {
+	    fprintf(stderr, "Cannot setup socket to remote_control_port %d\n",
+		    remote_control_port);
+	    exit(1) ;
+	}
+	printf("remote control socket fd is %d\n", remote_control_socket);
+	wm->add_fd_to_watch(remote_control_socket);
+    }
+
+}
+
+
+int Remote::get_connection(int socket_fd)
+{
+    struct sockaddr	socket_addr ;	/* general socket */
+    struct sockaddr_in	peer_adr ;	/* inet socket */
+    int		fd, n, i ;
+    unsigned	char	*pi ;
+    socklen_t	len;
+
+    len = sizeof(socket_addr) ;	/* changed by call below */
+    if ((fd = accept(socket_fd, &socket_addr, &len)) < 0) {
+	perror("accept") ;
+	return(-1) ;
+    }
+    len = sizeof(peer_adr) ;
+    n = getpeername(fd, (struct sockaddr *) &peer_adr, &len) ;
+    if (n != 0) {
+	perror("get_connection: Unable to get peer name") ;
+    } else {
+	if (verbose) {
+	    fprintf(stderr, "peername is ") ;
+	}
+	if (peer_adr.sin_family != AF_INET) {
+	    fprintf(stderr, "Family %d (not AF_INET!) ", peer_adr.sin_family) ;
+	} else {
+	    if (verbose) {
+		fprintf(stderr, " port %d  ip adr ", ntohs(peer_adr.sin_port)) ;
+	    }
+	    pi = (unsigned char *) &peer_adr.sin_addr ;
+	    if (verbose) {
+		for (i=0; i<4; i++) {
+		    fprintf(stderr, "%d%s", *pi++,  (i==3)?"":".") ;
+		}
+	    }
+	}
+	fprintf(stderr, "\n") ;
+    }
+    return(fd) ;
+}
+
+
+
+
+typedef enum {
+    err_no_error,
+    err_invalid_number,
+    err_no_such_window,
+    err_missing_args,
+    err_invalid_command,
+    err_syntax_error,
+    err_quit,		// not an error
+    err_unknown,	// so we always give a reply
+} cmd_errors;
+
+static char *err_strings[] = {
+    "OK\n\n",
+    "Invalid number\n\n",
+    "No such windowid\n\n",
+    "Missing argument(s)\n\n",
+    "Invalid command\n\n",
+    "Syntax error\n\n",
+    "Bye\n\n",
+    "Unknown error\n\n",
+};
+
+void give_reply(int fd, cmd_errors e) {
+    int inv_err = sizeof(err_strings)/sizeof(err_strings[0]);
+
+    if (e >= inv_err) {
+	fprintf(stderr, "give_reply: invalid error number %d\n", e);
+	e = err_unknown;
+    }
+    write(fd, err_strings[e], strlen(err_strings[e]));
+}
+	      
+cmd_errors list_clients(WindowManager * mgr, char *buff, int fd) {
+    mgr->print_clients(fd);
+    return err_no_error;
+}
+
+
+Boolean get_num(char **p, int *num) {
+    char *q;
+    long x;
+
+    while ( isspace(**p) ) {
+	(*p)++;
+    }
+    x = strtol(*p, &q, 0);
+    if ( *q == '\0' || isspace(*q) ) {
+	*num = (int) x;
+	*p = q;
+	return true;
+    } else {
+	return false;
+    }
+}
+
+Boolean get_signed_num(char **p, int *num, char *initial) {
+    char *q;
+    long x;
+
+    while ( isspace(**p) ) {
+	(*p)++;
+    }
+    if (**p == '+' || **p == '-') {
+	*initial = **p;
+	(*p)++;
+    } else {
+	*initial = ' ';
+    }
+    x = strtol(*p, &q, 0);
+    if ( *q == '\0' || isspace(*q) ) {
+	*num = (int) x;
+	*p = q;
+	return true;
+    } else {
+	return false;
+    }
+}
+    
+
+cmd_errors open_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    } else {
+	w = (Window) x;
+	Client *c = mgr->windowToClient(w, false);
+	if (c == NULL) {
+	    return err_no_such_window;
+	} else {
+	    c->unhide(True);
+	    c->mapRaised();
+	    c->ensureVisible();
+	}
+    }
+    return err_no_error;
+}
+
+cmd_errors hide_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    c->hide();
+    return err_no_error;
+}
+
+
+cmd_errors unhide_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    c->unhide(True);
+    return err_no_error;
+}
+
+cmd_errors move_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x, y;
+    Window w;
+    char sig_x, sig_y;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+
+    if (get_signed_num(&p, &x, &sig_x) && 
+	get_signed_num(&p, &y, &sig_y)) {
+	if (sig_x == '-') {
+	    x = DisplayWidth(c->display(), 0) - x;
+	}
+	if (sig_y == '-') {
+	    y = DisplayHeight(c->display(), 0) - y;
+	}
+	// printf("Moving window 0x%x to (%d, %d)\n", w, x, y);
+	c->move(x, y, False);
+	// c->ensureVisible();
+    } else {
+	return err_missing_args;
+    }
+    return err_no_error;
+}
+
+cmd_errors rmove_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x, y;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+
+    if (get_num(&p, &x) && get_num(&p, &y)) {
+	printf("Moving window 0x%x to (%d, %d)\n", w, x, y);
+	c->move(x, y, True);
+	// c->ensureVisible();
+    } else {
+	return err_missing_args;
+    }
+    return err_no_error;
+}
+
+cmd_errors maximize_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int n;
+    Window w;
+
+    if (!get_num(&(p=buff), &n)) {
+	return err_invalid_number;
+    }
+    w = (Window) n;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+
+    if (get_num(&p, &n)){
+	printf("maximize_client window 0x%x n =  %d\n", w, n);
+	c->maximise(n);
+    } else {
+	return err_missing_args;
+    }
+    return err_no_error;
+}
+
+cmd_errors unmaximize_client(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int n;
+    Window w;
+
+    if (!get_num(&(p=buff), &n)) {
+	return err_invalid_number;
+    }
+    w = (Window) n;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+
+    if (get_num(&p, &n)){
+	printf("unmaximize_client window 0x%x n =  %d\n", w, n);
+	c->unmaximise(n);
+    } else {
+	return err_missing_args;
+    }
+    return err_no_error;
+}
+
+cmd_errors raise_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    c->mapRaised();
+    return err_no_error;
+}
+
+cmd_errors raise_or_lower_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    c->raiseOrLower();
+    return err_no_error;
+}
+
+cmd_errors lower_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    c->lower();
+    return err_no_error;
+}
+
+cmd_errors relabel_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    while (isspace(*p)) {
+	p++;
+    }
+    if (*p == '\0') {
+	return err_missing_args;
+    }
+    c->setLabel(p);
+    return err_no_error;
+}
+
+cmd_errors warp_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+
+    c->unhide(True);
+    c->activateAndWarp();
+
+    return err_no_error;
+}
+
+cmd_errors window_to_channel_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    Window w;
+    Boolean leaving;
+    int active_channel = mgr->channel();
+    int channel;
+
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    w = (Window) x;
+    Client *c = mgr->windowToClient(w, false);
+    if (c == NULL) {
+	return err_no_such_window;
+    }
+    if (!get_num(&p, &channel)) {
+	return err_invalid_number;
+    }
+
+    leaving = (channel != active_channel);
+    if (!leaving) {
+	c->setChannel(channel);
+    }
+    c->flipChannel(leaving, channel);
+    if (leaving) {
+	c->setChannel(channel);
+    }
+    return err_no_error;;
+}
+
+
+cmd_errors go_to_channel_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+    int x;
+    char temp[1024];
+
+    if (strlen(buff) == 0) {
+	// no channel specified,  show current one
+	sprintf(temp, "Current channel is %d\n", mgr->channel());
+	write(fd, temp, strlen(temp));
+	return err_no_error;
+    }
+    if (!get_num(&(p=buff), &x)) {
+	return err_invalid_number;
+    }
+    mgr->gotoChannel(x, 0);
+    return err_no_error;
+}
+
+cmd_errors quit_cmd(WindowManager * mgr, char *buff, int fd) {
+    return err_quit;
+}
+
+cmd_errors options_cmd(WindowManager * mgr, char *buff, int fd) {
+    char *p;
+
+    fprintf(stderr, "processing options %s\n", buff);
+    p = buff;
+    while (isspace(*p)) p++;
+    if (*p) {
+	if (dConfig.update(p) == 0) {
+	    return err_no_error;
+	}
+    } 
+    return err_syntax_error;
+}
+
+// typedef int (WindowManager::*command_func)(char *buff, int fd);
+// typedef int (*command_func)(WindowManager * mgr, char *buff, int fd);
+typedef cmd_errors(*command_func)(WindowManager * mgr, char *buff, int fd);
+// typedef cmd_errors(*command_func)(Remote * mgr, char *buff, int fd);
+
+int Remote::parse_command(char *buff, int fd)
+{
+    int i;
+    char *p;
+    char reply[128];
+    struct {
+	char *command;
+	char *usage;
+	command_func func;
+    } table[] = {
+	{ "channel", " [<number>]", go_to_channel_cmd },
+	{ "clients", "", &list_clients },
+	{ "help", "", NULL },
+	{ "hide", " <window id>", hide_client },
+	{ "label", " <window id> <any string>", relabel_cmd },
+	{ "lower", " <window id>", lower_cmd },
+	{ "maximize", " <window id> <number>", maximize_client },
+	{ "move", " <window id> <x> <y>", move_client },
+	{ "open", " <window id>", open_client },
+	{ "options", " <options string>", options_cmd },
+	{ "quit", "", quit_cmd },
+	{ "raise", " <window id>", raise_cmd },
+	{ "raiseorlower", " <window id>", raise_or_lower_cmd },
+	{ "rmove", " <window id> <x> <y>", rmove_client },
+	{ "unhide", " <window id>", unhide_client },
+	{ "unmaximize", " <window id> <number>", unmaximize_client },
+	{ "warp", " <window id>", warp_cmd },
+	{ "wchannel", " <window id> <number>", window_to_channel_cmd },
+    };
+    int num_entries = sizeof(table)/sizeof(table[0]);
+    command_func func;
+    cmd_errors err;
+
+    // Remove any trailing newline/cr/lf
+    p = buff + strlen(buff) - 1;
+    while (*p == '\n' || *p == '\r') {
+	*p = '\0';
+	p--;
+    }
+    // Find where the first arg (if any) is
+    p = buff;
+    while (*p && !isspace(*p)) {
+	p++;
+    }
+
+    err = err_invalid_command;
+    for (i=0; i< num_entries; i++) {
+	if (strncmp(table[i].command, buff, strlen(table[i].command)) == 0) {
+	    func = table[i].func;
+	    if (func == NULL) {
+		// do help here since the table is local
+		int j;
+		sprintf(reply, "Commands are:\n");
+		write(fd, reply, strlen(reply));
+		for (j=0; j< num_entries; j++) {
+		    write(fd, table[j].command, strlen(table[j].command));
+		    write(fd, table[j].usage, strlen(table[j].usage));
+		    write(fd, "\n", 1);
+		}
+		err = err_no_error;
+		break;
+	    }
+	    // err = (*func)(this, p, fd);
+	    err = (*func)(wm, p, fd);
+	    break;
+	}
+    }
+    if (err == err_quit) {
+	// closeConnection(fd);
+	return -1;
+    }
+    give_reply(fd, err);
+    if (sigpipe_happened) {
+	sigpipe_happened = False;
+	return -1;
+    }
+    if (err == err_no_error) {
+	return 0;
+    } else {
+	return 1;
+    }
+}
+
+Boolean Remote::isRemoteControlFd(int fd)
+{
+    return (fd == remote_control_socket) ||
+	(FD_ISSET(fd, &remote_control_connections));
+}
+
+void Remote::closeConnection(int fd)
+{
+    close(fd);
+    FD_CLR(fd, &remote_control_connections);
+    wm->remove_fd_from_watch(fd);
+
+}
+
+void Remote::close_all_sockets(void) {
+    int fd;
+
+    if (remote_control_socket > 0) {
+	if (verbose) {
+	    printf("closing %d\n", remote_control_socket);
+	}
+	close(remote_control_socket);
+    }
+    for (fd = 3; fd < max_connection; fd++) {
+	if (FD_ISSET(fd, &remote_control_connections)) {
+	    printf("closing %d\n", fd);
+	    close(fd);
+	}
+    }
+}
+
+
+Boolean Remote::doRemoteControl(int fd)
+{
+    char buff[128];
+    int n;
+    int new_fd;
+    char welcome_msg[] = 
+	"Welcome to wmx remote control.  Type help for commands\n\n";
+
+    if (verbose) {
+	printf("WindowManager::doRemoteControl(%d)\n", fd);
+    }
+
+    if (fd == remote_control_socket) {
+	/* A new connection */
+	new_fd = get_connection(remote_control_socket);
+	if (new_fd < 0) {
+	    fprintf(stderr, "Error trying to get new connection\n");
+	    return False;
+	}
+	if (verbose) {
+	    printf("New connection on %d:  %d\n", 
+		   fd, new_fd);
+	}
+	if (new_fd >= max_connection) {
+	    int size;
+	    max_connection = new_fd + 1;
+	    // printf("max_connection is now %d\n", max_connection);
+	    size = max_connection * sizeof(Connection*);
+	    // printf("reallocating to size %d\n", size);
+	    connections = (Connection **)
+		realloc(connections, size);
+	}
+	// printf("setting connections[%d]\n", new_fd);
+	connections[new_fd] = new Connection(1024, new_fd);
+
+	FD_SET(new_fd, &remote_control_connections);
+	wm->add_fd_to_watch(new_fd);
+	write(new_fd, welcome_msg, strlen(welcome_msg));
+	return True;
+    }
+
+
+    if (FD_ISSET(fd, &remote_control_connections)) {
+	/* Activity on existing connection */
+	Connection *c = connections[fd];
+	n = c->store_input(this);
+	if (n < 0) {
+	    if (verbose) {
+		printf("Closing connection %d\n", fd);
+	    }
+	    delete c;
+	    connections[fd] = NULL;
+	    closeConnection(fd);
+	    return False;
+	}
+	return True;
+
+    }
+    fprintf(stderr,
+	    "WindowManager::doRemoteControl(%d) -- why were we called?\n", fd);
+    return False;
+}
+
+
--- ../wmx-6pl1-orig/Remote.h	1969-12-31 19:00:00.000000000 -0500
+++ Remote.h	2005-03-06 14:08:27.090236336 -0500
@@ -0,0 +1,55 @@
+
+#ifndef __REMOTE_H_
+#define __REMOTE_H_
+
+#include "Manager.h"
+
+class WindowManager;
+
+class Connection {
+ public:
+    Connection(int, int);
+    ~Connection();
+    int store_input(class Remote*);
+
+ private:
+    int fd;	// for debugging
+    char *buff;
+    int size;	// size allocated
+    int room;	// room left
+    char *p;	// next input goes here
+};
+
+class Remote {
+ public:
+    Remote(WindowManager *const);
+    ~Remote();
+    void Remote::setup_port(int port, int verbose);
+    int RemoteControlIsOn(void) { return remote_control_port; }
+    Boolean Remote::isRemoteControlFd(int fd);
+    Boolean Remote::doRemoteControl(int fd);
+    void closeConnection(int);
+    int parse_command(char *buff, int fd);
+    int	verbose; 
+    void close_all_sockets(void);
+
+ private:
+
+    WindowManager *wm;
+    int remote_control_port;
+    fd_set remote_control_connections;
+    int remote_control_socket;
+    int Remote::setup_socket(char *host, int port);
+
+    int Remote::get_connection(int socket_fd);
+
+    int max_connection;	// 1 + highest fd in connections
+    Connection **connections;
+
+    // why is this static?  (copied from Manager.h)
+    static void sigpipe_handler(int);
+
+
+};
+
+#endif
--- ../wmx-6pl1-orig/listmacro.h	2000-03-02 08:56:36.000000000 -0500
+++ listmacro.h	2005-03-06 14:08:27.095235576 -0500
@@ -34,6 +34,7 @@
     void remove_all(); \
     void move_to_start(long index); \
     void move_to_end(long index); \
+    void sort( int (*func) (const void *, const void *) ); \
 \
 private: \
     T *m_items; \
@@ -89,6 +90,9 @@
     if (index < m_count-1) memmove(m_items+index, m_items+index+1, \
 				   (m_count-index-1) * sizeof(T)); \
     new (&m_items[m_count-1], this) T(temp); \
+} \
+void List::sort( int (*func) (const void *, const void *) ) { \
+    qsort(m_items, m_count, sizeof(T), func); \
 }
 
 #endif
